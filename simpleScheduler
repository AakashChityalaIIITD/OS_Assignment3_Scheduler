#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <time.h>

#define MAXPWD 1000
#define MAXHISTORY 1000

typedef struct {
    char* name;
    pid_t pid;
    time_t start_time;
    double* completion_time_time;
    double* wait_time;
} JobHistory;

JobHistory history[MAXHISTORY];
int history_count = 0;

void job_history(){
    printf("%-5s %-40s %-10s %-20s %s","No.", "Job Name", "PID", "Completion_time Time", "Wait Time");

    for(int i =0; i< history_count; i++){
        printf("%-5d %-40s %-10d %-20s %s\n", i+1, history[i].name, history[i].pid, history[i].completion_time_time, history[i].wait_time);
    }
}

void add_history(char *name, pid_t pid, double *completion_time_time, double *wait_time){
    if(history_count<MAXHISTORY){
        history[history_count].name = name;
        history[history_count].pid = pid;
        history[history_count].completion_time_time = completion_time_time;
        history[history_count].wait_time = wait_time;
        history_count++;
    }else{
        printf("History is full");
    }
}


typedef struct {
    Process items[MAXPWD];
    int size;
} priorityQueue;


void swap(Process* a, Process* b){
    Process temp = *a;
    *a = *b;
    *b = temp;
}

void heapifyUp(priorityQueue* queue, int index){
    if (queue->items[(index - 1) / 2].priority > queue->items[index].priority) {
        swap(&queue->items[(index - 1) / 2], &queue->items[index]);
        heapifyUp(queue, (index - 1) / 2);
    }
}


void enqueue(priorityQueue* queue, Process process){
    queue->items[queue->size] = process;
    queue->size++;
    heapifyUp(queue, queue->size - 1);
}


int heapifyDown(priorityQueue* queue, int index){
    int smallest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;

    if (left < queue->size && queue->items[left].priority < queue->items[smallest].priority)
        smallest = left;

    if (right < queue->size && queue->items[right].priority < queue->items[smallest].priority)
        smallest = right;

    if (smallest != index) {
        swap(&queue->items[index], &queue->items[smallest]);
        heapifyDown(queue, smallest);
    }
}


Process dequeue(priorityQueue* queue){
    if (queue->size==0) {
        perror("Queue is empty\n");
    }

    Process item = queue->items[0];
    queue->size--;
    queue->items[0] = queue->items[queue->size];
    heapifyDown(queue, 0);
    return item;
}


Process view(priorityQueue* queue){
    if (!queue->size) {
        perror("Priority queue is empty\n");
    }
    return queue->items[0];
}

typedef struct {
    char name[10];
    int pid;         // Process ID
    double burst;      // Burst time
    double remaining_time;  // Remaining burst time
    double waiting_time;    // Waiting time for each process
    double completion_time; // Completion_time time for each process
    int priority;
} Process;

void roundRobinAlgo(priorityQueue* ready_queue, Process processes[], int NCPU, int no_of_processes, double tSlice){
    double current_time = 0;
    int completed_processes = 0;

    Process process_on_cpu[NCPU];
    int processor_state[NCPU];  // array to store whether CPU is running or ideal

    for(int i = 0; i<NCPU; i++){
        processor_state[i] = -1;  // initially making all cpu's as ideal
    }

    while(completed_processes < no_of_processes){

        for(int i = 0; i< NCPU; i++){
            if(ready_queue->size >0 && processor_state[i]==-1){
                process_on_cpu[i] = dequeue(ready_queue);
                processor_state[i] = 1; // cpu is now running
            }
        }

        for(int i = 0; i< NCPU; i++){
            if(processor_state[i] == 1){
                double time_on_cpu;
                if(process_on_cpu[i].remaining_time<tSlice){
                    time_on_cpu = process_on_cpu[i].remaining_time;
                }else{
                    time_on_cpu = tSlice;
                }

                process_on_cpu[i].remaining_time -= time_on_cpu;
                current_time += time_on_cpu;

                printf("Time %lf - %lf: Running PID:%d on CPU %d\n", current_time-time_on_cpu, current_time, process_on_cpu[i].pid, i+1);

                if(process_on_cpu[i].remaining_time==0){
                    process_on_cpu[i].completion_time = current_time;
                    completed_processes++;
                    processor_state[i] = -1; //process has been completed so we free the cpu
                }else{
                    enqueue(ready_queue,process_on_cpu[i]);
                    processor_state[i] = -1; // cpu is freed for next process
                }
            }
        }
    }

    for(int i = 0; i<no_of_processes; i++){
        processes[i].waiting_time = processes[i].completion_time - processes[i].burst;
    }

    printf("%-5s %-40s %-6s %-15s %-15s %s\n","No.", "Process Name", "PID", "Burst time", "Completion Time", "Wait Time");

    for(int i = 0; i< no_of_processes; i++){
        printf("%-5s %-40s %-6s %-15s %-15s %s\n", i+1, processes[i].name, processes[i].pid, processes[i].burst, processes[i].completion_time, processes[i].waiting_time);
    }

    double total_waiting_time;
    double total_completion_time;
    for(int i = 0; i< no_of_processes; i++){
        total_waiting_time += processes[i].waiting_time;
        total_completion_time += processes[i].completion_time;
    }

    printf("The average waiting time of round-robin scheduling process is: %ls\n", total_waiting_time/no_of_processes);
    printf("The completion waiting time of round-robin scheduling process is: %ls\n", total_completion_time/no_of_processes);
}




int main(){
    priorityQueue ready_queue = {};
    Process processes[] = {
        { "P1", 1, 10, 10, 0, 0, 3 },{ "P2", 2, 15, 15, 0, 0, 1 },{ "P3", 3, 20, 20, 0, 0, 2 }};

    enqueue(&ready_queue,processes[0]);
    enqueue(&ready_queue,processes[1]);
    enqueue(&ready_queue,processes[2]);

    Process top = view(&ready_queue);
    printf("Process name: %s | priority number: %d \n",top.name, top.priority);
    dequeue(&ready_queue);

    Process top2 = view(&ready_queue);
    printf("Process name: %s | priority number: %d\n",top2.name, top2.priority);

    int no_of_processes = 3;
    int NCPU = 2;
    double tSlice = 5;

    roundRobinAlgo(&ready_queue, processes, NCPU, no_of_processes, tSlice);


    return 0;
}

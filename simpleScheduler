#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/time.h>
#include <time.h>
#include <semaphore.h> 
#include <sys/ipc.h>
#include <sys/shm.h>

#define MAX_PROCESSES 100
#define MAX_PROGRAM_NAME 256

int cpu_count;  // Number of CPUs
int time_slice; // Time slice in milliseconds
int shmid;      // Shared memory ID for the scheduler queue

sem_t scheduler_semaphore; // Semaphore for the scheduler
sem_t print_semaphore;     // Semaphore for printing
sem_t scheduler_queue_semaphore; // Semaphore for queue access

struct ProcessQueue* process_queue;
struct ProcessQueue shell_queue;
struct TerminatedQueue* terminated_processes;

struct Process {
    pid_t pid; // Process ID
    char command[MAX_PROGRAM_NAME]; // Command name
    int state; // 0: Running, 1: Waiting, -1: Finished
    struct timeval start_time; // Start time of the process
    struct timeval end_time;   // End time of the process
    long long total_execution_time; // Total execution time in ms
    long long waiting_time; // Waiting time in ms
};

struct ProcessQueue {
    struct Process processes[MAX_PROCESSES]; // Array of processes
    int rear; // Rear index of the queue
};

struct TerminatedQueue {
    struct Process processes[MAX_PROCESSES]; // Array of terminated processes
    int rear; // Rear index of the terminated queue
};

void enqueue(struct ProcessQueue* queue, struct Process process) {
    if (queue->rear == MAX_PROCESSES - 1) {
        printf("Queue is full.\n");
        return;
    }
    queue->processes[++queue->rear] = process; // Increment rear and add process
}

void handleSIGUSR1(int signo) { // Signal to wake the scheduler
    sem_post(&scheduler_semaphore);
}

void printTerminatedQueue(struct TerminatedQueue* queue) {
    for (int i = 0; i <= queue->rear; i++) {
        long long waiting_time = ((queue->processes[i].end_time.tv_sec - queue->processes[i].start_time.tv_sec) * 1000) +
                                 ((queue->processes[i].end_time.tv_usec - queue->processes[i].start_time.tv_usec) / 1000);
        printf("Terminated Process with PID %d. Execution Time: %lld ms and Waiting Time: %lld ms\n", 
               queue->processes[i].pid, queue->processes[i].total_execution_time, waiting_time);
    }
}

// Signal handler for child process completion
void handleSIGCHLD(int signo) {
    int status;
    pid_t pid;

    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        sem_wait(&scheduler_queue_semaphore); // Lock the scheduler queue

        // Find the process in the scheduling queue
        for (int i = 0; i <= process_queue->rear; i++) {
            if (process_queue->processes[i].pid == pid) {
                process_queue->processes[i].state = -1; // Mark as finished
                gettimeofday(&process_queue->processes[i].end_time, NULL);
                
                // Calculate total execution time
                long long elapsed_time = (process_queue->processes[i].end_time.tv_sec - process_queue->processes[i].start_time.tv_sec) * 1000 +
                                          (process_queue->processes[i].end_time.tv_usec - process_queue->processes[i].start_time.tv_usec) / 1000;
                process_queue->processes[i].total_execution_time += elapsed_time;

                // Move the process to the terminated queue
                terminated_processes->processes[++terminated_processes->rear] = process_queue->processes[i];

                // Remove the process from the scheduling queue by shifting elements
                for (int j = i; j < process_queue->rear; j++) {
                    process_queue->processes[j] = process_queue->processes[j + 1];
                }
                process_queue->rear--;
                break;
            }
        }
        sem_post(&scheduler_queue_semaphore); // Unlock the scheduler queue
    }
}

int main() {
    // Initialize semaphores
    sem_init(&scheduler_semaphore, 0, 0);
    sem_init(&print_semaphore, 0, 1);
    sem_init(&scheduler_queue_semaphore, 0, 1);

    // Set up the SIGCHLD signal handler
    signal(SIGCHLD, handleSIGCHLD);

    // User input for CPUs and time slice
    printf("Enter the number of CPUs: ");
    scanf("%d", &cpu_count);
    printf("Enter the time quantum (TSLICE) in milliseconds: ");
    scanf("%d", &time_slice);

    // Register the SIGUSR1 signal handler
    signal(SIGUSR1, handleSIGUSR1);

    // Create shared memory for the process queue
    shmid = shmget(IPC_PRIVATE, sizeof(struct ProcessQueue), 0666 | IPC_CREAT);
    if (shmid < 0) {
        perror("shmget");
        exit(1);
    }

    process_queue = shmat(shmid, NULL, 0);
    if (process_queue == (void*) -1) {
        perror("shmat");
        exit(1);
    }
    process_queue->rear = -1;

    // Create shared memory for the terminated queue
    int terminated_shmid = shmget(IPC_PRIVATE, sizeof(struct TerminatedQueue), 0666 | IPC_CREAT);
    if (terminated_shmid < 0) {
        perror("shmget for terminated queue");
        exit(1);
    }

    terminated_processes = shmat(terminated_shmid, NULL, 0);
    if (terminated_processes == (void*) -1) {
        perror("shmat for terminated queue");
        exit(1);
    }
    terminated_processes->rear = -1;

    // Fork the SimpleScheduler process
    pid_t scheduler_pid = fork();
    if (scheduler_pid == 0) {
        // Child process (Scheduler)
        struct timespec ts;
        ts.tv_sec = 0;
        ts.tv_nsec = time_slice * 1000000; // Convert TSLICE to nanoseconds
        int i = 0;

        while (1) {
            if (i > process_queue->rear || i >= MAX_PROCESSES) {
                i = 0; // Reset i if it exceeds the queue
            }

            // Check if processes are waiting
            int available_processes = cpu_count; // CPUs available for execution

            for (; i <= process_queue->rear && available_processes > 0; i++) {
                if (process_queue->processes[i].state == 1) {
                    sem_wait(&print_semaphore); // Wait for permission to print
                    gettimeofday(&process_queue->processes[i].start_time, NULL);
                    kill(process_queue->processes[i].pid, SIGCONT);
                    process_queue->processes[i].state = 0; // Set state to running
                    available_processes--;
                    sem_post(&print_semaphore); // Allow others to print
                }
            }
            usleep(time_slice * 1000); // Sleep for the defined time slice

            // Stop running processes
            for (int j = 0; j <= process_queue->rear; j++) {
                if (process_queue->processes[j].state == 0) {
                    sem_wait(&print_semaphore); // Wait for permission to print
                    kill(process_queue->processes[j].pid, SIGSTOP);
                    gettimeofday(&process_queue->processes[j].end_time, NULL);
                    
                    // Calculate execution time
                    long long elapsed = (process_queue->processes[j].end_time.tv_sec - process_queue->processes[j].start_time.tv_sec) * 1000 +
                                        (process_queue->processes[j].end_time.tv_usec - process_queue->processes[j].start_time.tv_usec) / 1000;
                    process_queue->processes[j].total_execution_time += elapsed;
                    process_queue->processes[j].waiting_time += (process_queue->rear - 1) * time_slice;
                    process_queue->processes[j].state = 1; // Set state to waiting
                    sem_post(&print_semaphore); // Allow others to print
                }
            }
        }

    } else {
        // Parent process (Shell)
        shell_queue.rear = -1;

        while (1) {
            char command[MAX_PROGRAM_NAME];
            printf("\nSimpleShell$ ");
            scanf("%s", command);

            if (strcmp(command, "exit") == 0) {
                // Exit the shell
                break;
            } else if (strcmp(command, "submit") == 0) {
                // User submits a program
                char program[MAX_PROGRAM_NAME];
                scanf("%s", program);

                pid_t child_pid = fork();
                if (child_pid == 0) {
                    // Child process
                    usleep(time_slice * 1000);
                    execlp(program, program, NULL);
                    perror("Execution failed");
                    exit(1);
                } else {
                    // Parent process (Shell)
                    struct Process new_process;
                    new_process.pid = child_pid;
                    strcpy(new_process.command, program);
                    new_process.state = 1; // Initially in waiting state
                    new_process.total_execution_time = 0;
                    new_process.waiting_time = 0;

                    // Enqueue the new process
                    sem_wait(&scheduler_queue_semaphore); // Lock the scheduler queue
                    enqueue(process_queue, new_process);
                    sem_post(&scheduler_queue_semaphore); // Unlock the scheduler queue

                    printf("Process submitted with PID: %d\n", child_pid);
                }
            } else {
                printf("Unknown command: %s\n", command);
            }
        }
        kill(scheduler_pid, SIGTERM); // Terminate the scheduler
    }

    // Cleanup
    shmdt(process_queue);
    shmdt(terminated_processes);
    sem_destroy(&scheduler_semaphore);
    sem_destroy(&print_semaphore);
    sem_destroy(&scheduler_queue_semaphore);
    return 0;
}
